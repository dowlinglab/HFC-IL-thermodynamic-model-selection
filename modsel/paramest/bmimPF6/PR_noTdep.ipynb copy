{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "voluntary-ridge",
   "metadata": {},
   "source": [
    "# Fit emimTF2N data\n",
    "\n",
    "EoS: PR\n",
    "\n",
    "Parameter T dependence: Constant\n",
    "\n",
    "N (total fitting parameters): 2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "improved-meeting",
   "metadata": {},
   "source": [
    "## Import Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "contained-performance",
   "metadata": {},
   "outputs": [],
   "source": [
    "import idaes\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import scipy.optimize\n",
    "\n",
    "import sys\n",
    "sys.path.append('../')\n",
    "\n",
    "from pyomo.environ import (Constraint,\n",
    "                           Var,\n",
    "                           ConcreteModel,\n",
    "                           Expression,\n",
    "                           Param,\n",
    "                           Objective,\n",
    "                           SolverFactory,\n",
    "                           TransformationFactory,\n",
    "                           value)\n",
    "from pyomo.opt import TerminationCondition, SolverStatus\n",
    "\n",
    "from idaes.core import FlowsheetBlock\n",
    "import idaes.logger as idaeslog\n",
    "# Import the Generic Parameter Block\n",
    "from idaes.generic_models.properties.core.generic.generic_property import (\n",
    "        GenericParameterBlock)\n",
    "# Import unit models from the model library\n",
    "from idaes.generic_models.unit_models import Flash\n",
    "# Import degrees of freedom tool\n",
    "from idaes.core.util.model_statistics import degrees_of_freedom\n",
    "\n",
    "# parmest (binary_param2)\n",
    "from bip_fitting_functions import constant\n",
    "\n",
    "import scipy.stats as stats\n",
    "\n",
    "from matplotlib.patches import Ellipse\n",
    "import matplotlib.transforms as transforms\n",
    "import matplotlib.patches as mpatches"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "judicial-calculator",
   "metadata": {},
   "source": [
    "## Load Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "technological-freeze",
   "metadata": {},
   "outputs": [],
   "source": [
    "data_full = pd.read_csv('r32_emimtf2n_full.csv')\n",
    "data_subset = pd.read_csv('r32_emimtf2n_subset.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "swiss-sphere",
   "metadata": {},
   "source": [
    "## Load Configuration + Check DOF"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "independent-layout",
   "metadata": {},
   "outputs": [],
   "source": [
    "from hfc32_emimtf2n_PR import configuration "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "featured-nicholas",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WARNING: DEPRECATED: Using __getitem__ to return a set value from its\n",
      "    (ordered) position is deprecated.  Please use at()  (deprecated in 6.1,\n",
      "    will be removed in 7.0) (called from /Users/bridgettebefort/Dowling-\n",
      "    Maginn-Lab/DowlingLab/IL-MD/idaes-\n",
      "    pse/idaes/generic_models/properties/core/state_definitions/FTPx.py:178)\n",
      "The initial DOF is 7\n"
     ]
    }
   ],
   "source": [
    "m = ConcreteModel()\n",
    "m.fs = FlowsheetBlock(default={\"dynamic\": False})\n",
    "m.fs.properties = GenericParameterBlock(default=configuration)\n",
    "m.fs.F101 = Flash(default={\"property_package\": m.fs.properties,\n",
    "                           \"has_heat_transfer\": True,\n",
    "                           \"has_pressure_change\": True})\n",
    "DOF_initial = degrees_of_freedom(m)\n",
    "print('The initial DOF is {0}'.format(DOF_initial))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "veterinary-first",
   "metadata": {},
   "source": [
    "## Fit Parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "personal-parade",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2021-10-27 14:10:17 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:17 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:18 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:19 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:19 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:20 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:21 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:21 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:22 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:23 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:23 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:24 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:24 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:26 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:27 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:27 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:28 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:29 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:30 [INFO] idaes.init.fs.state_block: Property package initialization: infeasible - Converged to a locally infeasible point. Problem may be infeasible..\n",
      "2021-10-27 14:10:32 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:33 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:33 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:34 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:35 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:36 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "2021-10-27 14:10:37 [INFO] idaes.init.fs.state_block: Property package initialization: infeasible - Converged to a locally infeasible point. Problem may be infeasible..\n",
      "2021-10-27 14:10:38 [INFO] idaes.init.fs.state_block: Property package initialization: optimal - Optimal Solution Found.\n",
      "Ipopt 3.13.2: bound_relax_factor=0\n",
      "honor_original_bounds=no\n",
      "\n",
      "\n",
      "******************************************************************************\n",
      "This program contains Ipopt, a library for large-scale nonlinear optimization.\n",
      " Ipopt is released as open source code under the Eclipse Public License (EPL).\n",
      "         For more information visit http://projects.coin-or.org/Ipopt\n",
      "\n",
      "This version of Ipopt was compiled from source code available at\n",
      "    https://github.com/IDAES/Ipopt as part of the Institute for the Design of\n",
      "    Advanced Energy Systems Process Systems Engineering Framework (IDAES PSE\n",
      "    Framework) Copyright (c) 2018-2019. See https://github.com/IDAES/idaes-pse.\n",
      "\n",
      "This version of Ipopt was compiled using HSL, a collection of Fortran codes\n",
      "    for large-scale scientific computation.  All technical papers, sales and\n",
      "    publicity material resulting from use of the HSL codes within IPOPT must\n",
      "    contain the following acknowledgement:\n",
      "        HSL, a collection of Fortran codes for large-scale scientific\n",
      "        computation. See http://www.hsl.rl.ac.uk.\n",
      "******************************************************************************\n",
      "\n",
      "This is Ipopt version 3.13.2, running with linear solver ma27.\n",
      "\n",
      "Number of nonzeros in equality constraint Jacobian...:      914\n",
      "Number of nonzeros in inequality constraint Jacobian.:        0\n",
      "Number of nonzeros in Lagrangian Hessian.............:      918\n",
      "\n",
      "Total number of variables............................:      378\n",
      "                     variables with only lower bounds:      162\n",
      "                variables with lower and upper bounds:      162\n",
      "                     variables with only upper bounds:        0\n",
      "Total number of equality constraints.................:      376\n",
      "Total number of inequality constraints...............:        0\n",
      "        inequality constraints with only lower bounds:        0\n",
      "   inequality constraints with lower and upper bounds:        0\n",
      "        inequality constraints with only upper bounds:        0\n",
      "\n",
      "iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n",
      "   0  0.0000000e+00 6.62e-01 1.42e-14  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n",
      "   1  3.0771223e-06 6.61e-01 4.21e+02  -1.0 9.77e+04    -  5.54e-01 1.30e-03h  1\n",
      "   2  1.4579022e-01 5.90e-01 6.09e+03  -1.0 1.99e+05    -  7.74e-01 1.33e-01h  1\n",
      "   3  8.2195427e+00 4.98e-01 5.01e+04  -1.0 1.80e+05    -  7.94e-01 9.58e-01h  1\n",
      "   4  8.3025754e+00 4.84e-01 4.87e+04  -1.0 3.47e+04    -  2.76e-01 2.83e-02h  1\n",
      "   5  8.4198133e+00 4.64e-01 4.69e+04  -1.0 3.33e+04    -  9.51e-04 4.10e-02h  1\n",
      "   6  1.1374192e+01 1.90e-02 3.58e+04  -1.0 3.20e+04    -  2.07e-01 9.90e-01h  1\n",
      "   7  1.1460899e+01 6.75e-05 1.74e+03  -1.0 8.95e+02    -  9.54e-01 9.90e-01h  1\n",
      "   8  1.1461038e+01 6.33e-05 1.53e+06  -1.0 9.99e+02    -  5.77e-01 6.19e-02f  5\n",
      "   9  1.1461094e+01 6.28e-05 2.74e+06  -1.0 1.02e+03    -  3.91e-01 7.73e-03f  8\n",
      "iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n",
      "  10  1.1457396e+01 3.59e-03 1.47e+06  -1.0 1.35e+04    -  6.20e-02 2.47e-01f  3\n",
      "  11  1.1467416e+01 3.47e-03 1.57e+06  -1.0 3.58e+03    -  6.18e-01 9.90e-01h  1\n",
      "  12  1.1495081e+01 1.89e-03 1.63e+08  -1.0 1.08e+04    -  6.08e-01 9.90e-01H  1\n",
      "  13  1.1579278e+01 9.97e-04 1.35e+10  -1.0 1.82e+04    -  6.72e-01 9.90e-01H  1\n",
      "  14  1.1726519e+01 5.38e-04 2.06e+10  -1.0 1.91e+04    -  9.85e-01 9.90e-01H  1\n",
      "In iteration 14, 27 Slacks too small, adjusting variable bounds\n",
      "  15  1.1777391e+01 2.30e-04 1.96e+11  -1.0 4.84e+03    -  9.90e-01 9.90e-01h  1\n",
      "  16  1.1526008e+01 5.78e-03 3.37e+12  -1.7 2.07e+04    -  9.92e-01 1.00e+00f  1\n",
      "  17  1.1500917e+01 3.28e-04 2.53e-01  -1.7 7.09e+03    -  1.00e+00 1.00e+00h  1\n",
      "  18  1.1449658e+01 6.24e-03 1.01e+10  -5.7 1.20e+04    -  9.82e-01 9.70e-01f  1\n",
      "  19  1.1445400e+01 8.18e-04 1.32e-01  -5.7 5.20e+03    -  1.00e+00 1.00e+00h  1\n",
      "iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n",
      "  20  1.1445205e+01 1.61e-04 2.03e-02  -5.7 1.41e+03    -  1.00e+00 1.00e+00h  1\n",
      "  21  1.1445207e+01 8.31e-07 9.74e-05  -5.7 1.25e+02    -  1.00e+00 1.00e+00h  1\n",
      "  22  1.1445205e+01 2.01e-09 1.94e-07  -8.6 4.42e+00    -  1.00e+00 1.00e+00h  1\n",
      "\n",
      "Number of Iterations....: 22\n",
      "\n",
      "                                   (scaled)                 (unscaled)\n",
      "Objective...............:   1.1445205140482910e+01    1.1445205140482910e+01\n",
      "Dual infeasibility......:   1.9419522513743869e-07    1.9419522513743869e-07\n",
      "Constraint violation....:   2.0055188620915487e-09    2.0055188620915487e-09\n",
      "Complementarity.........:   3.5629820092647883e-09    3.5629820092647883e-09\n",
      "Overall NLP error.......:   2.9314958411085376e-09    1.9419522513743869e-07\n",
      "\n",
      "\n",
      "Number of objective function evaluations             = 55\n",
      "Number of objective gradient evaluations             = 23\n",
      "Number of equality constraint evaluations            = 55\n",
      "Number of inequality constraint evaluations          = 0\n",
      "Number of equality constraint Jacobian evaluations   = 23\n",
      "Number of inequality constraint Jacobian evaluations = 0\n",
      "Number of Lagrangian Hessian evaluations             = 22\n",
      "Total CPU secs in IPOPT (w/o function evaluations)   =      0.047\n",
      "Total CPU secs in NLP function evaluations           =      0.592\n",
      "\n",
      "EXIT: Optimal Solution Found.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The SSE at the optimal solution is 11.445205\n",
      "\n",
      "The values for the parameters are as follows:\n",
      "fs.properties.PR_kappa_A[emimTf2N,R32] = -0.02894149152636121\n",
      "fs.properties.PR_kappa_A[R32,emimTf2N] = -0.020541972796452503\n",
      "covariance_matrix                                         fs.properties.PR_kappa_A[emimTf2N,R32]  \\\n",
      "fs.properties.PR_kappa_A[emimTf2N,R32]                                0.004748   \n",
      "fs.properties.PR_kappa_A[R32,emimTf2N]                                0.000242   \n",
      "\n",
      "                                        fs.properties.PR_kappa_A[R32,emimTf2N]  \n",
      "fs.properties.PR_kappa_A[emimTf2N,R32]                                0.000242  \n",
      "fs.properties.PR_kappa_A[R32,emimTf2N]                                0.000012  \n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/bridgettebefort/opt/anaconda3/envs/idaes-pse-dev/lib/python3.7/site-packages/pyomo/contrib/interior_point/interface.py:418: RuntimeWarning: divide by zero encountered in true_divide\n",
      "  data = (duals_primals_lb/(primals - self._nlp.primals_lb()) +\n"
     ]
    }
   ],
   "source": [
    "parameters, obj_value, a = constant(data_subset, configuration, 'R32', 'emimTf2N', \"x_R32\", \"x_emimTf2N\", \n",
    "    init_temp =  298.15, init_press =   399400 , init_x_c1 =    0.417, init_x_c2 = 0.583,\n",
    "    init_kappa_A_2_1 = -0.0496, init_kappa_A_1_2 = -0.023, eps = 0.1, scaling_fac = 1e-9 , read=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "collect-amount",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Objective (SSE): 11.445205140482908\n"
     ]
    }
   ],
   "source": [
    "print('Objective (SSE):',obj_value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "fewer-madonna",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Covariance Matrix:\n",
      "[[4.74762839e-03 2.42043214e-04]\n",
      " [2.42043214e-04 1.23398279e-05]]\n"
     ]
    }
   ],
   "source": [
    "cov = np.array(a)\n",
    "print('Covariance Matrix:')\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "received-chuck",
   "metadata": {},
   "source": [
    "## Apply Parameters + Plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "homeless-banana",
   "metadata": {},
   "outputs": [],
   "source": [
    "solver = SolverFactory('ipopt')\n",
    "solver.options = {'tol': 1e-6}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "historical-spice",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.986\n",
      "0.864\n",
      "0.694\n",
      "0.552\n",
      "0.43\n",
      "0.328\n",
      "0.214\n",
      "0.99\n",
      "0.905\n",
      "0.782\n",
      "0.675\n",
      "0.583\n",
      "0.501\n",
      "0.43\n",
      "0.357\n",
      "0.995\n",
      "0.945\n",
      "0.867\n",
      "0.8\n",
      "0.736\n",
      "0.68\n",
      "0.632\n",
      "0.583\n",
      "0.998\n",
      "0.966\n",
      "0.916\n",
      "0.869\n",
      "0.825\n",
      "0.784\n",
      "0.746\n",
      "0.712\n"
     ]
    }
   ],
   "source": [
    "m = ConcreteModel()\n",
    "\n",
    "m.fs = FlowsheetBlock(default={\"dynamic\": False})\n",
    "\n",
    "m.fs.properties = GenericParameterBlock(default=configuration)\n",
    "\n",
    "m.fs.F101 = Flash(default={\"property_package\": m.fs.properties,\n",
    "                           \"has_heat_transfer\": True,\n",
    "                           \"has_pressure_change\": True})\n",
    "\n",
    "m.fs.F101.inlet.flow_mol.fix(1)\n",
    "m.fs.F101.inlet.temperature.fix(323.15)\n",
    "m.fs.F101.inlet.pressure.fix(399800)\n",
    "m.fs.F101.inlet.mole_frac_comp[0,'R32'].fix(0.5)\n",
    "\n",
    "m.fs.properties.PR_kappa_A['R32','emimTf2N'] = parameters['fs.properties.PR_kappa_A[R32,emimTf2N]']\n",
    "m.fs.properties.PR_kappa_A['emimTf2N','R32'] = parameters['fs.properties.PR_kappa_A[emimTf2N,R32]']\n",
    "\n",
    "# Initialize the flash unit\n",
    "m.fs.F101.initialize(outlvl=idaeslog.CRITICAL)\n",
    "\n",
    "# Fix the state variables on the state block\n",
    "# m.fs.F101.inlet.pressure.unfix()\n",
    "m.fs.F101.inlet.mole_frac_comp[0,'emimTf2N'].unfix()\n",
    "\n",
    "R32_x = np.zeros((len(data_full)))\n",
    "P = np.zeros((len(data_full)))\n",
    "\n",
    "m.fs.liq = Param(mutable=True,default=0.040)\n",
    "m.fs.liquid = Constraint(expr=m.fs.F101.liq_outlet.mole_frac_comp[0, \"emimTf2N\"] == m.fs.liq)\n",
    "\n",
    "for i in range(len(data_full)):\n",
    "    m.fs.liq = data_full[\"x_emimTf2N\"].iloc[i]\n",
    "    m.fs.F101.inlet.temperature.fix(float(data_full[\"temperature\"].iloc[i]))\n",
    "    m.fs.F101.inlet.pressure.fix(float(data_full[\"pressure\"].iloc[i]))\n",
    "    m.fs.F101.inlet.mole_frac_comp[0,'R32'].fix(float(data_full[\"x_R32\"].iloc[i])+0.1)\n",
    "    m.fs.F101.inlet.mole_frac_comp[0,'emimTf2N'].fix(float(1-(data_full[\"x_R32\"].iloc[i]+0.1)))\n",
    "    m.fs.F101.vap_outlet.temperature.fix(float(data_full[\"temperature\"].iloc[i]))\n",
    "    \n",
    "#     DOF_final = degrees_of_freedom(m)\n",
    "#     print(\"The final DOF is {0}\".format(DOF_final))\n",
    "    m.fs.F101.initialize(outlvl=idaeslog.CRITICAL)\n",
    "    \n",
    "    status = solver.solve(m, tee = False)\n",
    "\n",
    "#     m.fs.F101.report()\n",
    "    if (status.solver.status == SolverStatus.ok) and (status.solver.termination_condition == TerminationCondition.optimal):\n",
    "        print(data_full[\"x_emimTf2N\"].iloc[i])\n",
    "        R32_x[i] = value(m.fs.F101.liq_outlet.mole_frac_comp[0,'R32']) \n",
    "        P[i] = value(m.fs.F101.vap_outlet.pressure[0])\n",
    "\n",
    "    else:\n",
    "        print('Infeasible.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "helpful-powell",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "P1= np.zeros((len(P)))\n",
    "\n",
    "for i in range(len(P)):\n",
    "    P1[i] = P[i]/1e6\n",
    "\n",
    "fig, ax = plt.subplots()\n",
    "\n",
    "ax.plot(R32_x[0:7],P1[0:7],\"b*-\",label=\"T= 283 K\")  \n",
    "ax.plot(R32_x[7:15],P1[7:15],\"r*-\",label=\"T= 298 K\") \n",
    "ax.plot(R32_x[15:23],P1[15:23],\"c*-\",label=\"T= 323 K\") \n",
    "ax.plot(R32_x[23:31],P1[23:31],\"m-*\",label=\"T= 348 K\")\n",
    "ax.plot(data_full[\"x_R32\"],data_full[\"pressure\"]/1e6,\"*\",color='orange',label=\"data\")  \n",
    "\n",
    "# plt.title('Isotherm R32-[emim][TF2N]')\n",
    "ax.set_ylabel('Pressure, MPa',fontsize=24)\n",
    "ax.set_xlabel('HFC-32 Mole Fraction',fontsize=24)\n",
    "\n",
    "ax.set_xticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n",
    "ax.set_xticks([0.1, 0.3, 0.5, 0.7, 0.9],minor=True)\n",
    "ax.set_yticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2])\n",
    "ax.set_yticks([0.1, 0.3, 0.5, 0.7, 0.9, 1.1],minor=True)\n",
    "\n",
    "ax.tick_params(\"both\", direction=\"in\", which=\"both\", length=4, labelsize=20, pad=10)\n",
    "ax.tick_params(\"both\", which=\"major\", length=8)\n",
    "ax.xaxis.set_ticks_position(\"both\")\n",
    "ax.yaxis.set_ticks_position(\"both\")\n",
    "\n",
    "ax.legend(fontsize=12, handletextpad=0.00, loc=\"lower right\")#, bbox_to_anchor=(1, 0.5))\n",
    "fig.savefig('R32-emimTF2N-noTdep.pdf',bbox_inches='tight')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "incomplete-innocent",
   "metadata": {},
   "outputs": [],
   "source": [
    "def make_ellipse(mu, cov, ci=0.95):\n",
    "    e, v = np.linalg.eig(cov)\n",
    "  \n",
    "    alpha = np.arctan(v[0,1]/v[0,0])\n",
    "    angle = -alpha*180/np.pi \n",
    "    q = stats.chi2(2).ppf(ci)\n",
    "    e = Ellipse(mu, 2*np.sqrt(q*e[0]), 2*np.sqrt(q*e[1]), angle=angle)\n",
    "    return e"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "wanted-muslim",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.rcParams[\"font.family\"] = \"serif\"\n",
    "plt.rcParams[\"font.serif\"] = \"Times New Roman\"\n",
    "plt.rcParams[\"font.size\"] = 14\n",
    "\n",
    "mu = parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'], parameters['fs.properties.PR_kappa_A[emimTf2N,R32]']\n",
    "\n",
    "e = make_ellipse(mu, cov, ci=0.95)\n",
    "\n",
    "e.set_alpha(0.25)\n",
    "e.set_facecolor('black')\n",
    "e.set_zorder(10)\n",
    "\n",
    "ax = plt.subplot()\n",
    "\n",
    "ax.add_artist(e)\n",
    "ax.scatter(parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'],parameters['fs.properties.PR_kappa_A[emimTf2N,R32]'],c='black',label='Reported Parameter Values')\n",
    "\n",
    "# plt.title('95% confidence ellipse')\n",
    "plt.xlabel(\"$\\kappa_{21}$\")\n",
    "plt.ylabel(\"$\\kappa_{12}$\")\n",
    "\n",
    "# patch = mpatches.Patch(color='blue', label='Frequentist approach',alpha=1)\n",
    "\n",
    "# plt.legend(handles=[patch])\n",
    "plt.legend()\n",
    "ax.set(xlim=[-0.021, -0.02], ylim=[-0.03, -0.028])\n",
    "# plt.savefig('R32_hmimCl_ellipse.png')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dimensional-buying",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Why is the covariance matrix not printing on plot??"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "present-tulsa",
   "metadata": {},
   "source": [
    "### Print Eigvals, Eigvectors of Covariance\n",
    "\n",
    "An identifiability analysis can be performed with these as well as a FIM because the covariance matrix is the inverse of the FIM. That means that if there are any eigvals >> 0, their eigvecs indicate directions of un-identifiability."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "associate-retreat",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvals, eigvecs = np.linalg.eig(cov)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "genuine-lucas",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([4.75996822e-03, 2.91702731e-15])"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "eigvals"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "historic-outside",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.99870295, -0.05091579],\n",
       "       [ 0.05091579,  0.99870295]])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "eigvecs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "responsible-permission",
   "metadata": {},
   "source": [
    "Conclusion: Fully identifiable because all eigvals ~ 0 "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "advised-saint",
   "metadata": {},
   "source": [
    "## FIM with Enthalpy of Vaporization (and Pressure)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "textile-bermuda",
   "metadata": {},
   "source": [
    "### Step 1: Perturb Parameters, Calculate Enthalpy of Vaporization\n",
    "\n",
    "1. Perturb Parameters: stepsize = 0.001\n",
    "\n",
    "2. Holding all other parameters constant, calculate new pressure predictions at different temps, compositions \n",
    "\n",
    "*T = (T1=298, T2=323)\n",
    "\n",
    "*x = (0.01,0.2,0.325,0.4)\n",
    "\n",
    "*Pguess comes from data_full\n",
    "\n",
    "3. Save P, Use Clausius Clapeyron to calculate enthvap"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "tested-jones",
   "metadata": {},
   "outputs": [],
   "source": [
    "h = 0.001\n",
    "kR32_emimTF2N_plus = parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'] + h\n",
    "kR32_emimTF2N_minus = parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'] - h\n",
    "kemimTF2N_R32_plus = parameters['fs.properties.PR_kappa_A[emimTf2N,R32]'] + h\n",
    "kemimTF2N_R32_minus = parameters['fs.properties.PR_kappa_A[emimTf2N,R32]'] - h"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "human-michigan",
   "metadata": {},
   "outputs": [],
   "source": [
    "data = np.array([[kR32_emimTF2N_plus,parameters['fs.properties.PR_kappa_A[emimTf2N,R32]']],\n",
    "                [kR32_emimTF2N_minus,parameters['fs.properties.PR_kappa_A[emimTf2N,R32]']],\n",
    "                [parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'],kemimTF2N_R32_plus],\n",
    "               [parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'],kemimTF2N_R32_minus]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "painful-norman",
   "metadata": {},
   "outputs": [],
   "source": [
    "perturbed_params = pd.DataFrame(data=data,columns=['kR32_emimTF2N','kemimTF2N_R32'])\n",
    "perturbed_params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "stable-calculator",
   "metadata": {},
   "outputs": [],
   "source": [
    "x = [0.01,0.2,0.325,0.4]\n",
    "temps_298 = [298.15,298.15,298.15,298.15]\n",
    "pguess_298 = [9600,250000,399400,549000]\n",
    "temps_323 = [323.15,323.15,323.15,323.15]\n",
    "pguess_323 = [20400,400100,700300,1000000]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "latter-omega",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_298 = pd.DataFrame()\n",
    "test_298['temperature'] = temps_298\n",
    "test_298['pressure'] = pguess_298\n",
    "test_298['x_R32'] = x\n",
    "test_298['x_emimTf2N'] = 1-test_298['x_R32']\n",
    "# test_298"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cellular-accordance",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_323 = pd.DataFrame()\n",
    "test_323['temperature'] = temps_323\n",
    "test_323['pressure'] = pguess_323\n",
    "test_323['x_R32'] = x\n",
    "test_323['x_emimTf2N'] = 1-test_323['x_R32']\n",
    "# test_323"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "catholic-costa",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_data = pd.concat([test_298,test_323],ignore_index=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "induced-haven",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Loop through test values\n",
    "\n",
    "R32_x = np.zeros((len(perturbed_params),len(test_data)))\n",
    "P = np.zeros((len(perturbed_params),len(test_data)))\n",
    "\n",
    "for j in range(len(perturbed_params)):\n",
    "\n",
    "    m = ConcreteModel()\n",
    "\n",
    "    m.fs = FlowsheetBlock(default={\"dynamic\": False})\n",
    "\n",
    "    m.fs.properties = GenericParameterBlock(default=configuration)\n",
    "\n",
    "    m.fs.F101 = Flash(default={\"property_package\": m.fs.properties,\n",
    "                               \"has_heat_transfer\": True,\n",
    "                               \"has_pressure_change\": True})\n",
    "\n",
    "    m.fs.F101.inlet.flow_mol.fix(1)\n",
    "    m.fs.F101.inlet.temperature.fix(323.15)\n",
    "    m.fs.F101.inlet.pressure.fix(399800)\n",
    "    m.fs.F101.inlet.mole_frac_comp[0,'R32'].fix(0.5)\n",
    "\n",
    "    m.fs.properties.PR_kappa_A['R32','emimTf2N'] = perturbed_params['kR32_emimTF2N'][j]\n",
    "    m.fs.properties.PR_kappa_A['emimTf2N','R32'] = perturbed_params['kemimTF2N_R32'][j]\n",
    "\n",
    "    # Initialize the flash unit\n",
    "    m.fs.F101.initialize(outlvl=idaeslog.CRITICAL)\n",
    "\n",
    "    # Fix the state variables on the state block\n",
    "    # m.fs.F101.inlet.pressure.unfix()\n",
    "    m.fs.F101.inlet.mole_frac_comp[0,'emimTf2N'].unfix()\n",
    "\n",
    "    m.fs.liq = Param(mutable=True,default=0.040)\n",
    "    m.fs.liquid = Constraint(expr=m.fs.F101.liq_outlet.mole_frac_comp[0, \"emimTf2N\"] == m.fs.liq)\n",
    "\n",
    "    for i in range(len(test_data)):\n",
    "        m.fs.liq = test_data[\"x_emimTf2N\"].iloc[i]\n",
    "        m.fs.F101.inlet.temperature.fix(float(test_data[\"temperature\"].iloc[i]))\n",
    "        m.fs.F101.inlet.pressure.fix(float(test_data[\"pressure\"].iloc[i]))\n",
    "        m.fs.F101.inlet.mole_frac_comp[0,'R32'].fix(float(test_data[\"x_R32\"].iloc[i])+0.1)\n",
    "        m.fs.F101.inlet.mole_frac_comp[0,'emimTf2N'].fix(float(1-(test_data[\"x_R32\"].iloc[i]+0.1)))\n",
    "        m.fs.F101.vap_outlet.temperature.fix(float(test_data[\"temperature\"].iloc[i]))\n",
    "\n",
    "    #     DOF_final = degrees_of_freedom(m)\n",
    "    #     print(\"The final DOF is {0}\".format(DOF_final))\n",
    "        m.fs.F101.initialize(outlvl=idaeslog.CRITICAL)\n",
    "\n",
    "        status = solver.solve(m, tee = False)\n",
    "\n",
    "    #     m.fs.F101.report()\n",
    "        if (status.solver.status == SolverStatus.ok) and (status.solver.termination_condition == TerminationCondition.optimal):\n",
    "            print(test_data[\"x_emimTf2N\"].iloc[i])\n",
    "            R32_x[j,i] = value(m.fs.F101.liq_outlet.mole_frac_comp[0,'R32'])\n",
    "            P[j,i] = value(m.fs.F101.vap_outlet.pressure[0])\n",
    "\n",
    "        else:\n",
    "            print('Infeasible.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "collect-leisure",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_data['P_kR32_emimTF2N_plus'] = P[0]\n",
    "test_data['P_kR32_emimTF2N_minus'] = P[1]\n",
    "test_data['P_kemimTF2N_R32_plus'] = P[2]\n",
    "test_data['P_kemimTF2N_R32_minus'] = P[3]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "parallel-upgrade",
   "metadata": {},
   "outputs": [],
   "source": [
    "grad_P = test_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "level-venture",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_data_298 = test_data[test_data['temperature']==298.15]\n",
    "test_data_323 = test_data[test_data['temperature']==323.15].reset_index()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bright-groove",
   "metadata": {},
   "outputs": [],
   "source": [
    "R = 8.314 #J/mol-K\n",
    "hvap_calc_kR32_emimTF2N_plus = []\n",
    "for i in range(len(x)):\n",
    "    T2 = test_data_323['temperature'][i]\n",
    "    T1 = test_data_298['temperature'][i]\n",
    "    P2 = test_data_323['P_kR32_emimTF2N_plus'][i]\n",
    "    P1 = test_data_298['P_kR32_emimTF2N_plus'][i]\n",
    "    hvap_calc_kR32_emimTF2N_plus.append(np.log(P2/P1)*R/(1/T2-1/T1))\n",
    "\n",
    "hvap_calc_kR32_emimTF2N_minus = []\n",
    "for i in range(len(x)):\n",
    "    T2 = test_data_323['temperature'][i]\n",
    "    T1 = test_data_298['temperature'][i]\n",
    "    P2 = test_data_323['P_kR32_emimTF2N_minus'][i]\n",
    "    P1 = test_data_298['P_kR32_emimTF2N_minus'][i]\n",
    "    hvap_calc_kR32_emimTF2N_minus.append(np.log(P2/P1)*R/(1/T2-1/T1))\n",
    "    \n",
    "hvap_calc_kemimTF2N_R32_plus = []\n",
    "for i in range(len(x)):\n",
    "    T2 = test_data_323['temperature'][i]\n",
    "    T1 = test_data_298['temperature'][i]\n",
    "    P2 = test_data_323['P_kemimTF2N_R32_plus'][i]\n",
    "    P1 = test_data_298['P_kemimTF2N_R32_plus'][i]\n",
    "    hvap_calc_kemimTF2N_R32_plus.append(np.log(P2/P1)*R/(1/T2-1/T1))\n",
    "    \n",
    "hvap_calc_kemimTF2N_R32_minus = []\n",
    "for i in range(len(x)):\n",
    "    T2 = test_data_323['temperature'][i]\n",
    "    T1 = test_data_298['temperature'][i]\n",
    "    P2 = test_data_323['P_kemimTF2N_R32_minus'][i]\n",
    "    P1 = test_data_298['P_kemimTF2N_R32_minus'][i]\n",
    "    hvap_calc_kemimTF2N_R32_minus.append(np.log(P2/P1)*R/(1/T2-1/T1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "million-guyana",
   "metadata": {},
   "outputs": [],
   "source": [
    "hvap = pd.DataFrame()\n",
    "hvap['x_R32'] = x\n",
    "hvap['hvap_kR32_emimTF2N_plus'] = hvap_calc_kR32_emimTF2N_plus\n",
    "hvap['hvap_kR32_emimTF2N_minus'] = hvap_calc_kR32_emimTF2N_minus\n",
    "hvap['hvap_kemimTF2N_R32_plus'] = hvap_calc_kemimTF2N_R32_plus\n",
    "hvap['hvap_kemimTF2N_R32_minus'] = hvap_calc_kemimTF2N_R32_minus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "noble-brass",
   "metadata": {},
   "outputs": [],
   "source": [
    "hvap"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "quantitative-sodium",
   "metadata": {},
   "source": [
    "### Step 2: Calculate Gradient wrt each param at each concentration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "magnetic-encyclopedia",
   "metadata": {},
   "outputs": [],
   "source": [
    "grad_kR32_emimTF2N = (hvap['hvap_kR32_emimTF2N_plus'] - hvap['hvap_kR32_emimTF2N_minus'])/(2*h)\n",
    "grad_kemimTF2N_R32 = (hvap['hvap_kemimTF2N_R32_plus'] - hvap['hvap_kemimTF2N_R32_minus'])/(2*h)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "equipped-challenge",
   "metadata": {},
   "outputs": [],
   "source": [
    "grad_P['kR32_emimTF2N'] = (grad_P['P_kR32_emimTF2N_plus'] - grad_P['P_kR32_emimTF2N_minus'])/(2*h)\n",
    "grad_P['kemimTF2N_R32'] = (grad_P['P_kemimTF2N_R32_plus'] - grad_P['P_kemimTF2N_R32_minus'])/(2*h)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ultimate-korean",
   "metadata": {},
   "source": [
    "### Step 3: Build Jacobian and FIM\n",
    "\n",
    "Rows: enthvap @ 4 concentrations; or pressure @ 4 concentrations, 2 temperatures\n",
    "\n",
    "Columns: parameters (2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "marine-drama",
   "metadata": {},
   "outputs": [],
   "source": [
    "J_df = pd.DataFrame()\n",
    "J_df['kR32_emimTF2N'] = grad_kR32_emimTF2N\n",
    "J_df['kemimTF2N_R32'] = grad_kemimTF2N_R32"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "leading-vinyl",
   "metadata": {},
   "outputs": [],
   "source": [
    "J = J_df.to_numpy()\n",
    "Jtrans = np.transpose(J)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "faced-undergraduate",
   "metadata": {},
   "outputs": [],
   "source": [
    "FIM = np.dot(Jtrans,J)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "noble-player",
   "metadata": {},
   "outputs": [],
   "source": [
    "FIM"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "stable-packaging",
   "metadata": {},
   "outputs": [],
   "source": [
    "J_df_P = pd.DataFrame()\n",
    "J_df_P['kR32_emimTF2N'] = grad_P['kR32_emimTF2N']\n",
    "J_df_P['kemimTF2N_R32'] = grad_P['kemimTF2N_R32']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "rough-graduation",
   "metadata": {},
   "outputs": [],
   "source": [
    "J_P = J_df_P.to_numpy()\n",
    "J_Ptrans = np.transpose(J_P)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "complicated-smell",
   "metadata": {},
   "outputs": [],
   "source": [
    "FIM_P = np.dot(J_Ptrans,J_P)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "distinct-salmon",
   "metadata": {},
   "outputs": [],
   "source": [
    "FIM_P"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "varying-blowing",
   "metadata": {},
   "source": [
    "### Step 4: Find Eigenvalues, Eigenvectors"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "shared-george",
   "metadata": {},
   "source": [
    "**Enthalpy of Vaporization**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "leading-throw",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvals, eigvecs = np.linalg.eig(FIM)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "objective-creativity",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvals"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "disciplinary-creativity",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvecs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fluid-sunrise",
   "metadata": {},
   "source": [
    "All eigenvalues >> 0, assuming that these 2 parameters are identifiable with the given T, x, P data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "greek-gossip",
   "metadata": {},
   "source": [
    "**Pressure**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "earned-defense",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvals_P, eigvecs_P = np.linalg.eig(FIM_P)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "thick-grain",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvals_P"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "terminal-effort",
   "metadata": {},
   "outputs": [],
   "source": [
    "eigvecs_P"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "weighted-meeting",
   "metadata": {},
   "source": [
    "All eigvals >> 0, assuming these 2 parameters are identifiable with the given T, x, P data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "capital-declaration",
   "metadata": {},
   "source": [
    "## AIC Value\n",
    "\n",
    "See https://docs.google.com/document/d/1um0r2XK4ldjjy2colOqaZsEM3wIzGD6l_3B8gnpnI2I/edit# for equations"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "about-offering",
   "metadata": {},
   "source": [
    "### Calculate MLE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "cutting-chair",
   "metadata": {},
   "outputs": [],
   "source": [
    "### Define calc model P function\n",
    "\n",
    "def calcPmod(theta,data):\n",
    "    '''\n",
    "    Arguments:\n",
    "    theta - list of BIPs\n",
    "    data - data needed to run the model\n",
    "    \n",
    "    Returns\n",
    "    Pmod - list of calculated pressures\n",
    "    '''\n",
    "    \n",
    "    m = ConcreteModel()\n",
    "\n",
    "    m.fs = FlowsheetBlock(default={\"dynamic\": False})\n",
    "\n",
    "    m.fs.properties = GenericParameterBlock(default=configuration)\n",
    "\n",
    "    m.fs.F101 = Flash(default={\"property_package\": m.fs.properties,\n",
    "                               \"has_heat_transfer\": True,\n",
    "                               \"has_pressure_change\": True})\n",
    "\n",
    "    m.fs.F101.inlet.flow_mol.fix(1)\n",
    "    m.fs.F101.inlet.temperature.fix(323.15)\n",
    "    m.fs.F101.inlet.pressure.fix(399800)\n",
    "    m.fs.F101.inlet.mole_frac_comp[0,'R32'].fix(0.5)\n",
    "\n",
    "    m.fs.properties.PR_kappa_A['R32','emimTf2N'] = theta[0]\n",
    "    m.fs.properties.PR_kappa_A['emimTf2N','R32'] = theta[1]\n",
    "\n",
    "    # Initialize the flash unit\n",
    "    m.fs.F101.initialize(outlvl=idaeslog.CRITICAL)\n",
    "\n",
    "    # Fix the state variables on the state block\n",
    "    # m.fs.F101.inlet.pressure.unfix()\n",
    "    m.fs.F101.inlet.mole_frac_comp[0,'emimTf2N'].unfix()\n",
    "\n",
    "    R32_x = np.zeros((len(data)))\n",
    "    P = np.zeros((len(data)))\n",
    "\n",
    "    m.fs.liq = Param(mutable=True,default=0.040)\n",
    "    m.fs.liquid = Constraint(expr=m.fs.F101.liq_outlet.mole_frac_comp[0, \"emimTf2N\"] == m.fs.liq)\n",
    "\n",
    "    for i in range(len(data)):\n",
    "        m.fs.liq = data[\"x_emimTf2N\"].iloc[i]\n",
    "        m.fs.F101.inlet.temperature.fix(float(data[\"temperature\"].iloc[i]))\n",
    "        m.fs.F101.inlet.pressure.fix(float(data[\"pressure\"].iloc[i]))\n",
    "        m.fs.F101.inlet.mole_frac_comp[0,'R32'].fix(float(data[\"x_R32\"].iloc[i])+0.1)\n",
    "        m.fs.F101.inlet.mole_frac_comp[0,'emimTf2N'].fix(float(1-(data[\"x_R32\"].iloc[i]+0.1)))\n",
    "        m.fs.F101.vap_outlet.temperature.fix(float(data[\"temperature\"].iloc[i]))\n",
    "\n",
    "    #     DOF_final = degrees_of_freedom(m)\n",
    "    #     print(\"The final DOF is {0}\".format(DOF_final))\n",
    "        m.fs.F101.initialize(outlvl=idaeslog.CRITICAL)\n",
    "\n",
    "        status = solver.solve(m, tee = False)\n",
    "\n",
    "    #     m.fs.F101.report()\n",
    "        if (status.solver.status == SolverStatus.ok) and (status.solver.termination_condition == TerminationCondition.optimal):\n",
    "#             print(data[\"x_emimTf2N\"].iloc[i])\n",
    "            R32_x[i] = value(m.fs.F101.liq_outlet.mole_frac_comp[0,'R32']) \n",
    "            P[i] = value(m.fs.F101.vap_outlet.pressure[0])\n",
    "\n",
    "        else:\n",
    "            print('Infeasible.')\n",
    "            \n",
    "    Pmod = P\n",
    "    \n",
    "    return Pmod"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "mediterranean-oregon",
   "metadata": {},
   "outputs": [],
   "source": [
    "### Define function to calculate residual\n",
    "def res(theta,data,Pexp):\n",
    "    '''\n",
    "    Arguments:\n",
    "    theta - list of BIPs\n",
    "    data - data needed to run the model\n",
    "    Pexp - list of experimental pressure data\n",
    "    \n",
    "    Returns:\n",
    "    residual between model and exp (note, this will be large because of units of P)\n",
    "    '''\n",
    "    \n",
    "    #Calculate model P\n",
    "    Pmod = calcPmod(theta,data)\n",
    "    \n",
    "    return Pexp - Pmod"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "afraid-format",
   "metadata": {},
   "outputs": [],
   "source": [
    "theta_guess = [parameters['fs.properties.PR_kappa_A[R32,emimTf2N]'],parameters['fs.properties.PR_kappa_A[emimTf2N,R32]']]\n",
    "Pexp = data_subset['pressure'].values.tolist()\n",
    "n = 2\n",
    "bnds = ([-20,-20],[20,20])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "affected-dressing",
   "metadata": {},
   "outputs": [],
   "source": [
    "# theta0 = [-0.05,-0.04,-0.03,-0.02,-0.01,-0.001]\n",
    "# restest = []\n",
    "# for i in range(len(theta0)):\n",
    "#     theta_guess = [theta0[i],parameters['fs.properties.PR_kappa_A[emimTf2N,R32]']]\n",
    "#     restest.append(res(theta_guess,data_subset,Pexp,n))\n",
    "    \n",
    "# plt.plot(theta0,restest)\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "limiting-saskatchewan",
   "metadata": {},
   "outputs": [],
   "source": [
    "### solve\n",
    "sol = scipy.optimize.least_squares(res, theta_guess, method='trf', args=(data_subset,Pexp),bounds=bnds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "wanted-plane",
   "metadata": {},
   "outputs": [],
   "source": [
    "theta_hat = sol.x\n",
    "theta_hat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "centered-public",
   "metadata": {},
   "outputs": [],
   "source": [
    "def SSR(theta,data,Pexp):\n",
    "    '''\n",
    "    Arguments:\n",
    "    theta - list of BIPs\n",
    "    data - data needed to run the model\n",
    "    Pexp - list of experimental pressure data\n",
    "    \n",
    "    Returns:\n",
    "    SSR - sum of residuals squared\n",
    "    '''\n",
    "    \n",
    "    #Calculate model P\n",
    "    Pmod = calcPmod(theta,data)\n",
    "    \n",
    "    #Calculate residual squared\n",
    "    res = (Pexp - Pmod)**2\n",
    "    \n",
    "    #Sum residuals squared\n",
    "    SSR = np.sum(res)\n",
    "    \n",
    "    return SSR"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "editorial-masters",
   "metadata": {},
   "outputs": [],
   "source": [
    "SSR = SSR(theta_hat,data_subset,Pexp)\n",
    "SSR"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "weekly-artist",
   "metadata": {},
   "outputs": [],
   "source": [
    "sigma_sq = SSR/n\n",
    "sigma_sq"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "official-trouble",
   "metadata": {},
   "outputs": [],
   "source": [
    "L = -n/2*np.log(2*np.pi) - n/2*np.log(sigma_sq) - 1/(2*sigma_sq)*SSR\n",
    "L"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "absent-twist",
   "metadata": {},
   "outputs": [],
   "source": [
    "AIC = 2*n - 2*L\n",
    "AIC"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "tired-handle",
   "metadata": {},
   "source": [
    "Other AIC - using SSR calculated in above parameter fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "medical-antarctica",
   "metadata": {},
   "outputs": [],
   "source": [
    "SSR_other = obj_value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "capital-direction",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5.722602570241454"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sigma_sq_other = SSR_other/n\n",
    "sigma_sq_other"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "canadian-blast",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-4.582300763119763"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L_other = -n/2*np.log(2*np.pi) - n/2*np.log(sigma_sq_other) - 1/(2*sigma_sq_other)*SSR_other\n",
    "L_other"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "banner-clearing",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "13.164601526239526"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "AIC_other = 2*n - 2*L_other\n",
    "AIC_other"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "damaged-triangle",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
